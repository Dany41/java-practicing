package org.testframework;

import com.google.auto.service.AutoService;

import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;
import java.io.IOException;
import java.io.PrintWriter;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

@SupportedAnnotationTypes("org.testframework.annotation.Test")
@SupportedSourceVersion(SourceVersion.RELEASE_17)
@AutoService(Processor.class)
public class TestProcessor extends AbstractProcessor {
    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        for (TypeElement annotation : annotations) {
            Set<? extends Element> annotatedElements = roundEnv.getElementsAnnotatedWith(annotation);
            Map<Boolean, ? extends List<? extends Element>> collect = annotatedElements.stream().collect(
                    Collectors.partitioningBy(element -> element.getModifiers().contains(Modifier.STATIC))
            );
            List<? extends Element> validMethods = collect.get(true);
            List<? extends Element> invalidMethods = collect.get(false);

            invalidMethods.forEach(el -> processingEnv.getMessager().printMessage(
                    Diagnostic.Kind.ERROR,
                    "@Test must be applied on static methods", el));

            if (validMethods.isEmpty()) continue;

            String className = ((TypeElement) validMethods.get(0).getEnclosingElement()).getQualifiedName().toString();

            try {
                writeTestFile(className);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        return true;
    }

    private void writeTestFile(String className) throws IOException {
        String packageName = null;
        int lastDot = className.lastIndexOf('.');
        if (lastDot > 0) {
            packageName = className.substring(0, lastDot);
        }
        String generatedClassName = className + "_CustomGenerated";

        String generatedSimpleClassName = generatedClassName
                .substring(lastDot + 1);
        try {
            JavaFileObject testFile = processingEnv.getFiler().createSourceFile(generatedClassName);
            try (PrintWriter out = new PrintWriter(testFile.openWriter())) {
                if (packageName != null) {
                    out.print("package ");
                    out.print(packageName);
                    out.println(";");
                    out.println();
                }

                out.print("public class ");
                out.print(generatedSimpleClassName);
                out.print(" {");
                out.println();

                out.print("    public String generatedMethod() {");
                out.println();
                out.print("        return \"Generated by ");
                out.print(this.getClass().getSimpleName());
                out.print(" at: ");
                out.print(LocalDateTime.now());
                out.print("\";");
                out.println();
                out.println("    }");

                out.println("}");
                out.println();
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

    }
}
